<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.xusz.cn/</id>
    <title>Gridea</title>
    <updated>2019-08-15T07:48:54.004Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.xusz.cn/"/>
    <link rel="self" href="https://blog.xusz.cn//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.xusz.cn//images/avatar.png</logo>
    <icon>https://blog.xusz.cn//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Hello React （Vol. 2）]]></title>
        <id>https://blog.xusz.cn//post/hello-react-vol2</id>
        <link href="https://blog.xusz.cn//post/hello-react-vol2">
        </link>
        <updated>2019-08-15T05:06:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="purecomponent">PureComponent</h3>
<p>无状态组件多数为展示型组件，根据传递过来的数据，展示既定的内容，这种情形下，我们可以对无状态组件进行一定程度上的优化。</p>
<pre><code>
const Content = (props) =&gt; {
 console.log('Content')
 return (
  &lt;div&gt;{props.name}&lt;/div&gt;
 )
}

class App extends React.Component {

 state = {
  name: 'react'，
	num: [1, 2]
 }
 
 componentDidMount() {
  setInterval(() =&gt; {
	 this.setState({
	  name: 'react'
	 })
	}, 2000)
 }
 
 render() {
  console.log('render')
	return (
	 &lt;div&gt;
	  &lt;Content name={this.state.name} /&gt;
	 &lt;/div&gt;
	)
 }
 
}
</code></pre>
<p>以上代码中，组件挂载后，执行一个定时器，每隔2秒对name进行一个相同的赋值。这个时候，组件的state实际上是没有发生改变，但我们可以从控制台里看到，组件仍然在被render。显然，这会降低react的渲染效率。那么我们如何在组件状态未发生变化时，阻止组件重绘？</p>
<p>react提供了一个生命周期函数<code>shouldComponentUpdate</code>，这个函数返回布尔值，当返回值为false时，组件将不再进行渲染。</p>
<pre><code>shouldComponentUpdate(nextProps, nextState) {
 return (
  this.state.name === nextState.name ? false : true
 )
}
</code></pre>
<p>加上这个生命周期函数后，组件已经不再重绘，但是我们注意到，<code>shouldComponentUpdate</code>仍然在执行，这显然不是我们想要的结果。</p>
<p>这里，react引入了<code>PureComponent</code>组件，它和<code>Component</code>组件比较相似，只是<code>PureComponent</code>会对state和props进行<code>浅比较</code>：即当基本类型数据的值未发生改变时，视作不更新；引用类型数据的引用（内存中的地址）未发生改变时，同样视作不更新。</p>
<p>这里可以了解下<a href="https://github.com/immutable-js/immutable-js">immutable.js</a>。</p>
<p>修改Content组件</p>
<pre><code>...

class Content extends React.PureComponent {
 render() {
  console.log('render content')
	return (
	 &lt;div&gt;{this.props.name}&lt;/div&gt;
	)
 }
}

...
</code></pre>
<p>引用类型数据，直接更新数组的值，无法引起重绘，对象类型数据也一样。</p>
<pre><code>...

 componentDidMount() {
  let arr = this.state.num
	arr.push(3)
  setInterval(() =&gt; {
	 this.setState({
	  arr
	 })
	}, 2000)
 }

...
</code></pre>
<p>因此，可以根据数据的状态和组件的类型，合理的选择使用<code>Component</code> <code>PureComponent</code>和<code>shouldComponentUpdate</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello React （Vol.1）]]></title>
        <id>https://blog.xusz.cn//post/hr</id>
        <link href="https://blog.xusz.cn//post/hr">
        </link>
        <updated>2019-08-13T08:11:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>前端js框架，使用jsx快速构建用户界面。</p>
<ul>
<li>声明式</li>
<li>组件化</li>
<li>一次学习，随处编写</li>
</ul>
<h3 id="初试">初试</h3>
<p>通过script标签直接引入<code>react</code> <code>react-dom</code> <code>babel</code>，直接在浏览器中体验react。</p>
<pre><code>&lt;script src=&quot;https://cdn.bootcss.com/react/16.9.0-rc.0/umd/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.9.0-alpha.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/babel&quot;&gt;
	ReactDOM.render(
		&lt;h1&gt;Hello React&lt;/h1&gt;, 
		document.getElementById('app')
	)
&lt;/script&gt;
</code></pre>
<p>这里script的type属性必须是text/babel，然后会被编译成如下：</p>
<pre><code>&quot;use strict&quot;;
ReactDOM.render(React.createElement(&quot;h1&quot;, null, &quot;Hello React&quot;), document.getElementById('app'));
</code></pre>
<p>这里ReactDOM的render方法接收2个参数，第一个参数是ReactElement的实例，第二个是挂载的容器。这里不展开，详细的以后再学习。</p>
<h3 id="create-react-app">create-react-app</h3>
<h4 id="安装">安装</h4>
<p><code>npm install -g create-react-app</code></p>
<h4 id="创建项目">创建项目</h4>
<pre><code>create-react-app my-app
cd my-app
yarn start
</code></pre>
<p>没什么意外的话，可以很轻松的就跑起来了~</p>
<h3 id="一个组件">一个组件</h3>
<p>index.js -- 应用入口</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>app.js</p>
<pre><code>import React from 'react';

function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h1&gt;Welcome!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h3 id="多个组件">多个组件</h3>
<p>多个小组件，组合成一个更加复杂的组件。<br>
app.js</p>
<pre><code>...

// Header组件
const Header = ( props ) =&gt; ( &lt;h3&gt;Header, {props.name}&lt;/h3&gt; )

// Content组件
const Content = ( ) =&gt; ( &lt;h3&gt;Content&lt;/h3&gt; )

// Footer组件
const Footer = ( ) =&gt; ( &lt;h3&gt;Footer&lt;/h3&gt; )

function App() {
 return (
	&lt;div className=&quot;App&quot;&gt;
		&lt;h1&gt;Welcome!&lt;/h1&gt;
		&lt;Header  name='Wrap' /&gt;
		&lt;Content /&gt;
		&lt;Footer /&gt;
	&lt;/div&gt;
 );
}

...
</code></pre>
<h3 id="表达式">表达式</h3>
<h4 id="计算">计算</h4>
<pre><code>&lt;div&gt;{ 1 + 1 }&lt;/div&gt;
</code></pre>
<h4 id="字符串">字符串</h4>
<pre><code>&lt;div&gt;{ 'hello world' }&lt;/div&gt;
</code></pre>
<h4 id="三元运算">三元运算</h4>
<pre><code>&lt;div&gt;{ flag ? 'True' : 'False'  }&lt;/div&gt;
</code></pre>
<h4 id="数组">数组</h4>
<pre><code>const arr = [0, 1, true, false, ]
&lt;div&gt;{ arr }&lt;/div&gt;

&lt;div&gt;
 {
  arr.map((item, index) =&gt; {
		&lt;li&gt;{item}&lt;/li&gt;
	})
 }
&lt;/div&gt;
</code></pre>
<h3 id="数据传递">数据传递</h3>
<p>react是单向数据流的，数据只能自上而下的传递</p>
<h4 id="父组件传递到子组件">父组件传递到子组件</h4>
<pre><code>import React, {Component} from 'react';

const ChildComponent = (props) =&gt; {
	return (
		&lt;div&gt;Name is : {props.name}，Age is {props.age}
		 {
		  props.colors.map((color, index) =&gt; &lt;li key={index}&gt;{color}&lt;/li&gt;)
		 }
		&lt;/div&gt;
	)
}

class App extends Component {
 render() {
  const user = {
   name: 'Bill',
	 age: 12,
	 colors: ['red', 'blue', 'yellow']
  }
  return (
	 &lt;div classNames='container'&gt;
		 &lt;ChildComponent name={user.name} age={user.age} colors={user.colors}  /&gt;
	 &lt;/div&gt;
  )
 }
}
</code></pre>
<h4 id="子组件传递到父组件">子组件传递到父组件</h4>
<p>父组件传给子组件自定义函数</p>
<pre><code>class ParentComponent extends React.Component {
 constructor(props){
  super(props)
  this.state = {
	 name: ''
	}
 }
 
 handleChange = (e) =&gt; {
   this.setState({
    name: e.target.value
   })
 }
	
 render(){
  return (
	 &lt;div&gt;
	  &lt;h3&gt;You name is : {this.state.name}&lt;/h3&gt;
		&lt;Child updateName={this.handleChange} /&gt;
	 &lt;/div&gt;
	)
 }
}
</code></pre>
<p>子组件通过调用父组件传过来的函数，把数据返回给父组件</p>
<pre><code>const Child = (props) =&gt; {
 return (
  &lt;input
	 type=&quot;text&quot; 
   onChange={props.updateName} 
   placeholder='Please input you name'
  /&gt;
 )
}
</code></pre>
<h4 id="兄弟组件通信">兄弟组件通信</h4>
<p>兄弟组件通信太烦了<sub>割了</sub>以后学习context和redux吧</p>
<h3 id="数据类型检查">数据类型检查</h3>
<p>采用<code>prop-types</code>对数据进行类型验证，可以确保数据的准确性，快速定位存在的问题，防止因隐式转换带来的一些问题等。</p>
<pre><code>import PropTypes from 'prop-types';

...
ChildComponent.propTypes = {
 name: PropTypes.string,
 age: PropTypes.number，
 colors: PropTypes.array
}
...
</code></pre>
<h3 id="click事件">Click事件</h3>
<pre><code>class App extends Component {
 constructor(){
	this.state = {
	 age: 1
	}
 }
 
 add(){
  this.setState({
	 age: this.state.age + 1
	})
 }
 
 render() {
  return (
	 &lt;div classNames='container'&gt;
		 &lt;button onClick={ () =&gt; {this.add()} } &gt;{this.state.age}&lt;/button&gt;
	 &lt;/div&gt;
  )
 }
}
</code></pre>
<h3 id="无状态组件">无状态组件</h3>
<p>相同的输入，总会有相同的输出。组件的输出结果完全由props决定，且没有任何副作用</p>
<pre><code>const ChildComponent = (props) =&gt; {
	return (
		&lt;div&gt;
		 {
		  props.colors.map((color, index) =&gt; &lt;li key={index}&gt;{color}&lt;/li&gt;)
		 }
		&lt;/div&gt;
	)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://blog.xusz.cn//post/hello-gridea</id>
        <link href="https://blog.xusz.cn//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>