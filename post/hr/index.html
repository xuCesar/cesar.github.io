<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hello React （Vol.1） | Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://blog.xusz.cn//favicon.ico?v=1569085277054">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://blog.xusz.cn//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-145634641-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-145634641-1');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xusz.cn/">
  <img class="avatar" src="https://blog.xusz.cn//images/avatar.png?v=1569085277054" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Hello React （Vol.1）
            </h2>
            <div class="post-info">
              <span>
                2019-08-13
              </span>
              <span>
                3 min read
              </span>
              
                <a href="https://blog.xusz.cn//tag/5MDycT0WQ" class="post-tag">
                  # react
                </a>
              
                <a href="https://blog.xusz.cn//tag/rwNYpgwhX" class="post-tag">
                  # javascript
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="介绍">介绍</h3>
<p>前端js框架，使用jsx快速构建用户界面。</p>
<ul>
<li>声明式</li>
<li>组件化</li>
<li>一次学习，随处编写</li>
</ul>
<h3 id="初试">初试</h3>
<p>通过script标签直接引入<code>react</code> <code>react-dom</code> <code>babel</code>，直接在浏览器中体验react。</p>
<pre><code>&lt;script src=&quot;https://cdn.bootcss.com/react/16.9.0-rc.0/umd/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.9.0-alpha.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/babel&quot;&gt;
	ReactDOM.render(
		&lt;h1&gt;Hello React&lt;/h1&gt;, 
		document.getElementById('app')
	)
&lt;/script&gt;
</code></pre>
<p>这里script的type属性必须是text/babel，然后会被编译成如下：</p>
<pre><code>&quot;use strict&quot;;
ReactDOM.render(React.createElement(&quot;h1&quot;, null, &quot;Hello React&quot;), document.getElementById('app'));
</code></pre>
<p>这里ReactDOM的render方法接收2个参数，第一个参数是ReactElement的实例，第二个是挂载的容器。这里不展开，详细的以后再学习。</p>
<h3 id="create-react-app">create-react-app</h3>
<h4 id="安装">安装</h4>
<p><code>npm install -g create-react-app</code></p>
<h4 id="创建项目">创建项目</h4>
<pre><code>create-react-app my-app
cd my-app
yarn start
</code></pre>
<p>没什么意外的话，可以很轻松的就跑起来了~</p>
<h3 id="一个组件">一个组件</h3>
<p>index.js -- 应用入口</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>app.js</p>
<pre><code>import React from 'react';

function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h1&gt;Welcome!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h3 id="多个组件">多个组件</h3>
<p>多个小组件，组合成一个更加复杂的组件。<br>
app.js</p>
<pre><code>...

// Header组件
const Header = ( props ) =&gt; ( &lt;h3&gt;Header, {props.name}&lt;/h3&gt; )

// Content组件
const Content = ( ) =&gt; ( &lt;h3&gt;Content&lt;/h3&gt; )

// Footer组件
const Footer = ( ) =&gt; ( &lt;h3&gt;Footer&lt;/h3&gt; )

function App() {
 return (
	&lt;div className=&quot;App&quot;&gt;
		&lt;h1&gt;Welcome!&lt;/h1&gt;
		&lt;Header  name='Wrap' /&gt;
		&lt;Content /&gt;
		&lt;Footer /&gt;
	&lt;/div&gt;
 );
}

...
</code></pre>
<h3 id="表达式">表达式</h3>
<h4 id="计算">计算</h4>
<pre><code>&lt;div&gt;{ 1 + 1 }&lt;/div&gt;
</code></pre>
<h4 id="字符串">字符串</h4>
<pre><code>&lt;div&gt;{ 'hello world' }&lt;/div&gt;
</code></pre>
<h4 id="三元运算">三元运算</h4>
<pre><code>&lt;div&gt;{ flag ? 'True' : 'False'  }&lt;/div&gt;
</code></pre>
<h4 id="数组">数组</h4>
<pre><code>const arr = [0, 1, true, false, ]
&lt;div&gt;{ arr }&lt;/div&gt;

&lt;div&gt;
 {
  arr.map((item, index) =&gt; {
		&lt;li&gt;{item}&lt;/li&gt;
	})
 }
&lt;/div&gt;
</code></pre>
<h3 id="数据传递">数据传递</h3>
<p>react是单向数据流的，数据只能自上而下的传递</p>
<h4 id="父组件传递到子组件">父组件传递到子组件</h4>
<pre><code>import React, {Component} from 'react';

const ChildComponent = (props) =&gt; {
	return (
		&lt;div&gt;Name is : {props.name}，Age is {props.age}
		 {
		  props.colors.map((color, index) =&gt; &lt;li key={index}&gt;{color}&lt;/li&gt;)
		 }
		&lt;/div&gt;
	)
}

class App extends Component {
 render() {
  const user = {
   name: 'Bill',
	 age: 12,
	 colors: ['red', 'blue', 'yellow']
  }
  return (
	 &lt;div classNames='container'&gt;
		 &lt;ChildComponent name={user.name} age={user.age} colors={user.colors}  /&gt;
	 &lt;/div&gt;
  )
 }
}
</code></pre>
<h4 id="子组件传递到父组件">子组件传递到父组件</h4>
<p>父组件传给子组件自定义函数</p>
<pre><code>class ParentComponent extends React.Component {
 constructor(props){
  super(props)
  this.state = {
	 name: ''
	}
 }
 
 handleChange = (e) =&gt; {
   this.setState({
    name: e.target.value
   })
 }
	
 render(){
  return (
	 &lt;div&gt;
	  &lt;h3&gt;You name is : {this.state.name}&lt;/h3&gt;
		&lt;Child updateName={this.handleChange} /&gt;
	 &lt;/div&gt;
	)
 }
}
</code></pre>
<p>子组件通过调用父组件传过来的函数，把数据返回给父组件</p>
<pre><code>const Child = (props) =&gt; {
 return (
  &lt;input
	 type=&quot;text&quot; 
   onChange={props.updateName} 
   placeholder='Please input you name'
  /&gt;
 )
}
</code></pre>
<h4 id="兄弟组件通信">兄弟组件通信</h4>
<p>兄弟组件通信太烦了<sub>割了</sub>以后学习context和redux吧</p>
<h3 id="数据类型检查">数据类型检查</h3>
<p>采用<code>prop-types</code>对数据进行类型验证，可以确保数据的准确性，快速定位存在的问题，防止因隐式转换带来的一些问题等。</p>
<pre><code>import PropTypes from 'prop-types';

...
ChildComponent.propTypes = {
 name: PropTypes.string,
 age: PropTypes.number，
 colors: PropTypes.array
}
...
</code></pre>
<h3 id="click事件">Click事件</h3>
<pre><code>class App extends Component {
 constructor(){
	this.state = {
	 age: 1
	}
 }
 
 add(){
  this.setState({
	 age: this.state.age + 1
	})
 }
 
 render() {
  return (
	 &lt;div classNames='container'&gt;
		 &lt;button onClick={ () =&gt; {this.add()} } &gt;{this.state.age}&lt;/button&gt;
	 &lt;/div&gt;
  )
 }
}
</code></pre>
<h3 id="无状态组件">无状态组件</h3>
<p>相同的输入，总会有相同的输出。组件的输出结果完全由props决定，且没有任何副作用</p>
<pre><code>const ChildComponent = (props) =&gt; {
	return (
		&lt;div&gt;
		 {
		  props.colors.map((color, index) =&gt; &lt;li key={index}&gt;{color}&lt;/li&gt;)
		 }
		&lt;/div&gt;
	)
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E5%88%9D%E8%AF%95">初试</a></li>
<li><a href="#create-react-app">create-react-app</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">创建项目</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6">一个组件</a></li>
<li><a href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6">多个组件</a></li>
<li><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97">计算</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97">三元运算</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92">数据传递</a>
<ul>
<li><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6">父组件传递到子组件</a></li>
<li><a href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E5%88%B0%E7%88%B6%E7%BB%84%E4%BB%B6">子组件传递到父组件</a></li>
<li><a href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">兄弟组件通信</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">数据类型检查</a></li>
<li><a href="#click%E4%BA%8B%E4%BB%B6">Click事件</a></li>
<li><a href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6">无状态组件</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xusz.cn//post/hello-gridea">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://blog.xusz.cn//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
